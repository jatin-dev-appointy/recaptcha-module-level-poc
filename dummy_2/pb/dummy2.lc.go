// Code generated by protoc-gen-lc, DO NOT EDIT.

package pb

import (
	"context"

	"github.com/grpc-ecosystem/go-grpc-middleware/logging/zap/ctxzap"
	"go.opencensus.io/trace"
	"go.uber.org/zap"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"

	metrictracker "go.saastack.io/metric-tracker"
)

type localDummy2Client struct {
	Dummy2Server
}

func NewLocalDummy2Client(s Dummy2Server) Dummy2Client {
	return &localDummy2Client{s}
}

type traceDummy2Server struct {
	Dummy2Server
}

func NewTraceDummy2Server(in Dummy2Server) Dummy2Server {
	return &traceDummy2Server{in}
}

type metricDummy2Server struct {
	srv Dummy2Server
	mt  *metrictracker.MetricTracker
}

func NewDummy2MetricServer(in Dummy2Server, mt *metrictracker.MetricTracker) Dummy2Server {
	if mt == nil {
		mt = &metrictracker.MetricTracker{}
	}
	return &metricDummy2Server{
		srv: in,
		mt:  mt,
	}
}

func (lc *localDummy2Client) GetDummy2Method1(ctx context.Context, in *GetDummy2Method1Request, opts ...grpc.CallOption) (*Dummy2Method1Object, error) {
	if in == nil {
		return nil, status.Error(codes.InvalidArgument, "request cannot be null")
	}
	return lc.Dummy2Server.GetDummy2Method1(ctx, in)
}

func (s *traceDummy2Server) GetDummy2Method1(ctx context.Context, in *GetDummy2Method1Request) (*Dummy2Method1Object, error) {
	if in == nil {
		return nil, status.Error(codes.InvalidArgument, "request cannot be null")
	}

	ctx = ctxzap.ToContext(ctx, ctxzap.Extract(ctx).With(zap.String("service.name", ".dummy_2.Dummy2")))
	ctx, span := trace.StartSpan(ctx, ".dummy_2.Dummy2.GetDummy2Method1")
	defer span.End()
	// method call
	res, err := s.Dummy2Server.GetDummy2Method1(ctx, in)
	st, _ := status.FromError(err)
	span.SetStatus(trace.Status{Code: int32(st.Code()), Message: st.Message()})
	return res, err
}

func (m *metricDummy2Server) GetDummy2Method1(ctx context.Context, in *GetDummy2Method1Request) (res *Dummy2Method1Object, err error) {
	if in == nil {
		return nil, status.Error(codes.InvalidArgument, "request cannot be null")
	}
	span := m.mt.Start(".dummy_2.Dummy2.GetDummy2Method1")
	defer func() {
		m.mt.Done(span, err != nil)
	}()

	res, err = m.srv.GetDummy2Method1(ctx, in)
	return res, err
}

func (lc *localDummy2Client) GetDummy2Method2(ctx context.Context, in *GetDummy2Method2Request, opts ...grpc.CallOption) (*Dummy2Method2Object, error) {
	if in == nil {
		return nil, status.Error(codes.InvalidArgument, "request cannot be null")
	}
	return lc.Dummy2Server.GetDummy2Method2(ctx, in)
}

func (s *traceDummy2Server) GetDummy2Method2(ctx context.Context, in *GetDummy2Method2Request) (*Dummy2Method2Object, error) {
	if in == nil {
		return nil, status.Error(codes.InvalidArgument, "request cannot be null")
	}

	ctx = ctxzap.ToContext(ctx, ctxzap.Extract(ctx).With(zap.String("service.name", ".dummy_2.Dummy2")))
	ctx, span := trace.StartSpan(ctx, ".dummy_2.Dummy2.GetDummy2Method2")
	defer span.End()
	// method call
	res, err := s.Dummy2Server.GetDummy2Method2(ctx, in)
	st, _ := status.FromError(err)
	span.SetStatus(trace.Status{Code: int32(st.Code()), Message: st.Message()})
	return res, err
}

func (m *metricDummy2Server) GetDummy2Method2(ctx context.Context, in *GetDummy2Method2Request) (res *Dummy2Method2Object, err error) {
	if in == nil {
		return nil, status.Error(codes.InvalidArgument, "request cannot be null")
	}
	span := m.mt.Start(".dummy_2.Dummy2.GetDummy2Method2")
	defer func() {
		m.mt.Done(span, err != nil)
	}()

	res, err = m.srv.GetDummy2Method2(ctx, in)
	return res, err
}
