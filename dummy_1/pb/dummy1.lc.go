// Code generated by protoc-gen-lc, DO NOT EDIT.

package pb

import (
	"context"

	"github.com/grpc-ecosystem/go-grpc-middleware/logging/zap/ctxzap"
	"go.opencensus.io/trace"
	"go.uber.org/zap"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"

	metrictracker "go.saastack.io/metric-tracker"
)

type localDummy1Client struct {
	Dummy1Server
}

func NewLocalDummy1Client(s Dummy1Server) Dummy1Client {
	return &localDummy1Client{s}
}

type traceDummy1Server struct {
	Dummy1Server
}

func NewTraceDummy1Server(in Dummy1Server) Dummy1Server {
	return &traceDummy1Server{in}
}

type metricDummy1Server struct {
	srv Dummy1Server
	mt  *metrictracker.MetricTracker
}

func NewDummy1MetricServer(in Dummy1Server, mt *metrictracker.MetricTracker) Dummy1Server {
	if mt == nil {
		mt = &metrictracker.MetricTracker{}
	}
	return &metricDummy1Server{
		srv: in,
		mt:  mt,
	}
}

func (lc *localDummy1Client) GetDummy1Method1(ctx context.Context, in *GetDummy1Method1Request, opts ...grpc.CallOption) (*Dummy1Method1Object, error) {
	if in == nil {
		return nil, status.Error(codes.InvalidArgument, "request cannot be null")
	}
	return lc.Dummy1Server.GetDummy1Method1(ctx, in)
}

func (s *traceDummy1Server) GetDummy1Method1(ctx context.Context, in *GetDummy1Method1Request) (*Dummy1Method1Object, error) {
	if in == nil {
		return nil, status.Error(codes.InvalidArgument, "request cannot be null")
	}

	ctx = ctxzap.ToContext(ctx, ctxzap.Extract(ctx).With(zap.String("service.name", ".dummy_1.Dummy1")))
	ctx, span := trace.StartSpan(ctx, ".dummy_1.Dummy1.GetDummy1Method1")
	defer span.End()
	// method call
	res, err := s.Dummy1Server.GetDummy1Method1(ctx, in)
	st, _ := status.FromError(err)
	span.SetStatus(trace.Status{Code: int32(st.Code()), Message: st.Message()})
	return res, err
}

func (m *metricDummy1Server) GetDummy1Method1(ctx context.Context, in *GetDummy1Method1Request) (res *Dummy1Method1Object, err error) {
	if in == nil {
		return nil, status.Error(codes.InvalidArgument, "request cannot be null")
	}
	span := m.mt.Start(".dummy_1.Dummy1.GetDummy1Method1")
	defer func() {
		m.mt.Done(span, err != nil)
	}()

	res, err = m.srv.GetDummy1Method1(ctx, in)
	return res, err
}

func (lc *localDummy1Client) GetDummy1Method2(ctx context.Context, in *GetDummy1Method2Request, opts ...grpc.CallOption) (*Dummy1Method2Object, error) {
	if in == nil {
		return nil, status.Error(codes.InvalidArgument, "request cannot be null")
	}
	return lc.Dummy1Server.GetDummy1Method2(ctx, in)
}

func (s *traceDummy1Server) GetDummy1Method2(ctx context.Context, in *GetDummy1Method2Request) (*Dummy1Method2Object, error) {
	if in == nil {
		return nil, status.Error(codes.InvalidArgument, "request cannot be null")
	}

	ctx = ctxzap.ToContext(ctx, ctxzap.Extract(ctx).With(zap.String("service.name", ".dummy_1.Dummy1")))
	ctx, span := trace.StartSpan(ctx, ".dummy_1.Dummy1.GetDummy1Method2")
	defer span.End()
	// method call
	res, err := s.Dummy1Server.GetDummy1Method2(ctx, in)
	st, _ := status.FromError(err)
	span.SetStatus(trace.Status{Code: int32(st.Code()), Message: st.Message()})
	return res, err
}

func (m *metricDummy1Server) GetDummy1Method2(ctx context.Context, in *GetDummy1Method2Request) (res *Dummy1Method2Object, err error) {
	if in == nil {
		return nil, status.Error(codes.InvalidArgument, "request cannot be null")
	}
	span := m.mt.Start(".dummy_1.Dummy1.GetDummy1Method2")
	defer func() {
		m.mt.Done(span, err != nil)
	}()

	res, err = m.srv.GetDummy1Method2(ctx, in)
	return res, err
}
